# Microservicio de Pacientes ‚Äì Versi√≥n Java 11

## üéØ Objetivo general

Implementar un microservicio RESTful en Java 11 usando Spring Boot que gestione pacientes. El proyecto debe aplicar
buenas pr√°cticas de Programaci√≥n Orientada a Objetos (POO), arquitectura en capas, manejo de excepciones personalizadas,
y separaci√≥n entre modelo y vista mediante DTOs.

## üß© Fase 1: CRUD de Pacientes

### ‚úÖ M√≥dulo 1-A: Operaciones CRUD B√°sicas

Crear un microservicio que permita realizar operaciones CRUD sobre pacientes.

Los pacientes deben tener los siguientes campos:

- nombre (String)
- apellido (String)
- dni (String)
- obraSocial (String)
- email (String)
- telefono (String)

Permitir b√∫squeda filtrada por:

- DNI exacto
- Nombre (parcial, no sensible a may√∫sculas/min√∫sculas)

La informaci√≥n de los pacientes se almacenar√° utilizando un repositorio (puede ser una lista en memoria, una base de
datos H2 o cualquier otra implementaci√≥n que se considere adecuada).

### ‚úÖ M√≥dulo 1-B: Manejo de Excepciones Personalizadas

Implementar excepciones personalizadas:

- PacienteNoEncontradoException: cuando se intente buscar, editar o eliminar un paciente que no existe.
- PacienteDuplicadoException: cuando se intente crear un paciente con un DNI ya existente.
- Manejar las excepciones con mensajes claros al usuario usando @ControllerAdvice o try-catch.

## üß© Fase 2: Arquitectura y Mejores Pr√°cticas

### ‚úÖ M√≥dulo 2-A: Divisi√≥n en Capas (Arquitectura MVC)

Dividir el proyecto en al menos tres capas:

- Modelo: contiene la clase Paciente.
- Controlador (Controller): expone los endpoints REST.
- Servicio (Service): contiene la l√≥gica de negocio.
- Repositorio (Repository): define la abstracci√≥n de almacenamiento.
- (Opcional) Configuraci√≥n, Excepciones, etc.

### ‚úÖ M√≥dulo 2-B: Uso de DTOs y Mappers

- Crear una clase PacienteDTO que exponga solo los datos necesarios del paciente (por ejemplo: nombre, apellido, DNI,
  obra social).
- Implementar una clase PacienteMapper para convertir entre Paciente y PacienteDTO.

## üîÅ Fase 3: Persistencia real (opcional o futura)

- Reemplazar la lista en memoria por una base de datos persistente utilizando Spring Data JPA.
- Configurar H2 o cualquier otra base de datos relacional.
- Agregar anotaciones como @Entity, @Id, etc. en la clase Paciente.

> [!NOTE]
> üìå Consideraciones

- El microservicio debe estar desarrollado en Java 11.
- Debe utilizar Spring Boot (versi√≥n m√≠nima compatible con Java 11).
- Se valora el uso de @RestController, @Service, @Repository, DTOs y validaciones simples.
- El c√≥digo debe ser claro, legible y estar organizado por paquetes.

## Fase 4: Documentaci√≥n y Mensajer√≠a

### ‚úÖ Parte A: Documentaci√≥n de la API con Swagger (SpringDoc OpenAPI)

- üìö Objetivo: Documentar de manera autom√°tica los endpoints del microservicio usando Swagger, permitiendo probarlos
  desde una interfaz web (/swagger-ui.html o /swagger-ui/index.html).
- Instalar la dependencia springdoc-openapi-ui.
- Probar que aparezca la documentaci√≥n.
- (Opcional) Agregar anotaciones @Operation, @Parameter o @ApiResponse para enriquecer la docu.
- üß† Beneficio: les ayuda a visualizar los endpoints y compartir su API con otros f√°cilmente.

### ‚úÖ Parte B: Centralizaci√≥n de Excepciones con @ControllerAdvice

- üìö Objetivo: Implementar una clase global que maneje las excepciones personalizadas del microservicio, devolviendo
  mensajes claros y estados HTTP adecuados.
- Crear una clase GlobalExceptionHandler.
- Usar @ExceptionHandler para capturar PacienteNoEncontradoException y PacienteDuplicadoException.
- Retornar objetos ResponseEntity con c√≥digo de error y mensaje.
- üß† Beneficio: muestra una pr√°ctica real de c√≥mo se manejan errores de forma profesional en aplicaciones REST.

## üê≥ Fase 5: Contenerizaci√≥n con Docker + MySQL

### üéØ Objetivo

- Contenerizar el microservicio usando Docker. Sustituir la base de datos H2 en memoria por una base de datos MySQL
  montada tambi√©n como contenedor. Usar Docker Compose para orquestar ambos contenedores (app + db) y un archivo .env
  para manejar variables de entorno.

## Fase 6: Implementaci√≥n e Integraci√≥n de Stored Procedures

### üéØ Objetivo

- Extender el microservicio para incluir l√≥gica almacenada directamente en la base de datos. En esta etapa, deber√°n:
- Crear y poblar la base de datos MySQL con registros de pacientes.
- Implementar procedimientos almacenados (stored procedures) para consultas espec√≠ficas.
- Invocar esos procedimientos desde el repositorio en Java.
- Exponerlos a trav√©s de la API REST de forma limpia y documentada.

### ‚úÖ M√≥dulo 6-A: Crear script init.sql

1. Crear un archivo llamado init.sql con el siguiente contenido:
    - Carga de datos de ejemplo: al menos 10 registros realistas en la tabla paciente.

    - Definici√≥n de stored procedures:
        - `buscar_paciente_por_dni(IN p_dni VARCHAR(20))`: devuelve un √∫nico paciente por DNI.
        - `buscar_pacientes_por_nombre(IN p_nombre VARCHAR(50))`: devuelve pacientes cuyo nombre contenga el valor
          parcial recibido (insensible a may√∫sculas).
        - `buscar_pacientes_por_obra_social_paginado(IN p_obra_social VARCHAR(50), IN p_limit INT, IN p_offset INT)`:
          devuelve pacientes de una obra social con paginaci√≥n estilo limit/offset.

```sql
init.sql
-- Datos de ejemplo para la tabla paciente
INSERT INTO paciente (dni, nombre, apellido, obra_social, email, telefono) VALUES
('12345678', 'Carlos', 'P√©rez', 'OSDE', 'carlos.perez@example.com', '111-1111'),
('23456789', 'Ana', 'G√≥mez', 'Swiss Medical', 'ana.gomez@example.com', '222-2222'),
('34567890', 'Luis', 'Mart√≠nez', 'OSDE', 'luis.martinez@example.com', '333-3333'),
('45678901', 'Mar√≠a', 'L√≥pez', 'Galeno', 'maria.lopez@example.com', '444-4444'),
('56789012', 'Jorge', 'S√°nchez', 'OSDE', 'jorge.sanchez@example.com', '555-5555'),
('67890123', 'Luc√≠a', 'Fern√°ndez', 'Swiss Medical', 'lucia.fernandez@example.com', '666-6666'),
('78901234', 'Pedro', 'Ram√≠rez', 'Medicus', 'pedro.ramirez@example.com', '777-7777'),
('89012345', 'Laura', 'Su√°rez', 'Galeno', 'laura.suarez@example.com', '888-8888'),
('90123456', 'Sof√≠a', 'Guti√©rrez', 'OSDE', 'sofia.gutierrez@example.com', '999-9999'),
('01234567', 'Diego', 'Herrera', 'Medicus', 'diego.herrera@example.com', '101-0101');

-- Procedimiento 1: buscar paciente por DNI
DELIMITER //

CREATE PROCEDURE buscar_paciente_por_dni(IN p_dni VARCHAR(20))
BEGIN
SELECT dni, nombre, apellido, obra_social, email, telefono
FROM paciente
WHERE dni = p_dni;
END;
//

-- Procedimiento 2: buscar pacientes por nombre parcial (case-insensitive)
CREATE PROCEDURE buscar_pacientes_por_nombre(IN p_nombre VARCHAR(50))
BEGIN
SELECT dni, nombre, apellido, obra_social, email, telefono
FROM paciente
WHERE LOWER(nombre) LIKE CONCAT('%', LOWER(p_nombre), '%');
END;
//

-- Procedimiento 3: buscar pacientes por obra social con paginaci√≥n
CREATE PROCEDURE buscar_pacientes_por_obra_social_paginado(
IN p_obra_social VARCHAR(50),
IN p_limit INT,
IN p_offset INT
)
BEGIN
SELECT dni, nombre, apellido, obra_social, email, telefono
FROM paciente
WHERE obra_social = p_obra_social
LIMIT p_limit OFFSET p_offset;
END;
//

DELIMITER ;
```

2. Configurar docker-compose.yml para que el contenedor MySQL ejecute autom√°ticamente init.sql al inicializarse

```yaml
volumes:
  - ./01_init.sql:/docker-entrypoint-initdb.d/01_init.sql
```

3. Definir el archivo .env con las variables necesarias para la base de datos.

### ‚úÖ M√≥dulo 6-B: Invocar los Stored Procedures desde Java

1. En la interfaz PacienteRepository, agregar m√©todos que ejecuten los stored procedures utilizando @Query(
   value = "...", nativeQuery = true) o @Procedure.

```java

@Query(value = "CALL buscar_paciente_por_dni(:dni)", nativeQuery = true)
Optional<Paciente> buscarPorDniConSP(@Param("dni") String dni);
```

2. Desde la capa de servicios, invocar los m√©todos del repositorio y mapear los resultados a PacienteDTO.
3. Manejar posibles errores (por ejemplo, si no se encuentra un paciente) usando excepciones personalizadas como
   PacienteNoEncontradoException.

### ‚úÖ M√≥dulo 6-C: Exponer Endpoints REST

- Agregar endpoints en el controlador que permitan consultar los stored procedures desde la API REST. Ejemplo de
  endpoints:

| Endpoint                   | M√©todo | Descripci√≥n                                    |
|----------------------------|--------|------------------------------------------------|
| /pacientes/dni/{dni}       | GET    | Busca un paciente por DNI (via SP)             |
| /pacientes/nombre/{nombre} | GET    | Busca pacientes por nombre parcial (via SP)    |
| /pacientes/obra-social     | GET    | Busca pacientes por obra social con paginaci√≥n |

- El endpoint /obra-social debe recibir los par√°metros:
    - `obraSocial`, `page`, `size` como `@RequestParam`

### üìå Requisitos t√©cnicos

- Usar MySQL en Docker, reemplazando la base en memoria.
- Spring Boot con Spring Data JPA.
- El script SQL debe ejecutarse autom√°ticamente en la creaci√≥n del contenedor.
- Resolver las b√∫squedas solicitadas usando exclusivamente los stored procedures implementados.

## üß© Fase 7: Migraci√≥n a Arquitectura Hexagonal (Ports & Adapters)

### üéØ Objetivo

- Reestructurar el microservicio para adoptar una arquitectura hexagonal, tambi√©n conocida como Arquitectura de Puertos
  y Adaptadores, donde el dominio central queda aislado de las tecnolog√≠as externas (frameworks, base de datos, web,
  etc.).
-

### ‚úÖ M√≥dulo 7-A: Propuesta de Estructura de Carpetas

```bash
src/
‚îî‚îÄ‚îÄ main/
    ‚îî‚îÄ‚îÄ java/
        ‚îî‚îÄ‚îÄ microservice/
            ‚îî‚îÄ‚îÄ pacientes/
                ‚îú‚îÄ‚îÄ application/
                ‚îÇ   ‚îú‚îÄ‚îÄ domain/
                ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/
                ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Paciente.java
                ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ port/
                ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ in/
                ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ out/
                ‚îÇ   ‚îî‚îÄ‚îÄ service/
                ‚îÇ       ‚îî‚îÄ‚îÄ PacienteService.java
                ‚îú‚îÄ‚îÄ infrastructure/
                ‚îÇ   ‚îî‚îÄ‚îÄ adapter/
                ‚îÇ       ‚îú‚îÄ‚îÄ in/rest/
                ‚îÇ       ‚îî‚îÄ‚îÄ out/persistence/
                ‚îî‚îÄ‚îÄ shared/
                    ‚îî‚îÄ‚îÄ ...
```

### ‚úÖ M√≥dulo 7-B: Principios a Aplicar

- La capa `domain` es el n√∫cleo del sistema, y no depende de ninguna tecnolog√≠a.
    - Contiene los modelos (Paciente) y los puertos (port/in y port/out).
    - Los puertos definen interfaces, no implementaciones.
- La capa `application` implementa la l√≥gica de negocio (los casos de uso) orquestando los puertos.
- La capa `infrastructure` contiene los adaptadores que se conectan a tecnolog√≠as externas como Spring MVC, JPA,
  Swagger, etc.
    - `adapter/in/rest` conecta el mundo web (controllers).
    - `adapter/out/persistence` conecta con la base de datos (repositorios, entidades JPA, mapeadores).
- shared agrupa componentes transversales como excepciones.

### ‚úÖ M√≥dulo 7-C: Migraci√≥n guiada a Arquitectura Hexagonal

- Migr√° el proyecto desde MVC a una arquitectura hexagonal basada en puertos y adaptadores, reorganizando
  responsabilidades seg√∫n las siguientes acciones:

#### üìå Pasos a seguir

1. Modelo de dominio (Paciente)
    - Ubicaci√≥n: application.domain.model
    - Representa el paciente dentro del negocio.
    - Sin anotaciones de frameworks.
2. Definir puertos (interfaces)
    - port.in: PacienteUseCase define las operaciones disponibles.
    - port.out: PacienteRepositoryPort define c√≥mo se accede a los datos.
3. Casos de uso (PacienteService)
    - Ubicaci√≥n: application.service
    - Implementa PacienteUseCase, usa PacienteRepositoryPort.
4. Controlador REST
    - Ubicaci√≥n: infrastructure.adapter.in.rest
    - Se conecta solo con PacienteUseCase. No accede a entidades ni repos directamente.
5. Adapter de persistencia
    - Ubicaci√≥n: infrastructure.adapter.out.persistence
    - Implementa PacienteRepositoryPort usando JpaRepository y stored procedures.
    - Incluye clase PacienteEntity con anotaciones JPA.
6. DTOs REST (PacienteRequest, PacienteResponse)
    - Ubicaci√≥n: infrastructure.adapter.in.rest.dto
    - Modelos para entrada y salida de la API.
    - Solo contienen los datos necesarios para el cliente.
    - Permiten cambiar la interfaz sin afectar al dominio ni a la base de datos.
7. Mappers
    - Ubicaci√≥n seg√∫n el adapter correspondiente (rest.mapper, persistence.mapper)
    - Transforman entre modelos:
        - REST ‚Üî Dominio
        - Persistencia ‚Üî Dominio

## üß† Buenas pr√°cticas a reforzar

- Cada capa solo conoce las capas m√°s internas.
- El dominio es independiente de tecnolog√≠a.
- Los puertos son contratos; los adapters los implementan.
- Los DTOs y entidades son detalles t√©cnicos, no parte del modelo central.

## üß© Fase 8: Principios SOLID + Patrones de Dise√±o

### üéØ Objetivo

- Refactorizar el microservicio implementando expl√≠citamente los principios SOLID y patrones de dise√±o. Cada miembro del
  equipo debe elegir un principio SOLID y patr√≥n espec√≠fico, investigar su aplicaci√≥n, implementarlo y presentar su
  soluci√≥n al resto del equipo explicando las mejoras introducidas.
- üìã Tabla de Asignaci√≥n de Principios y Patrones

| Miembro del Equipo | Principio SOLID                 | Patr√≥n de dise√±o |
|--------------------|---------------------------------|------------------|
| Dani               | Liskov Substitution Principle   | Factory Method   |
| Emi                | Segregaci√≥n de Interfaces       | Proxy            |
| Fer                | Dependency Injection (DI)       | Template Method  |
| Guada              | Single Responsibility Principle | Observer         |
| Marcos             |                                 |                  |
| Nico               | Open/Closed Principle (OCP)     | Strategy         |

## ‚úÖ M√≥dulo 8-A: Implementaci√≥n de Principios SOLID

### üìå Tareas por Principio SOLID

- Cada miembro que elija un principio SOLID debe:
    - Investigar el principio asignado y comprender su prop√≥sito
    - Identificar en el c√≥digo actual del microservicio d√≥nde se viola el principio
    - Implementar una refactorizaci√≥n que demuestre la aplicaci√≥n correcta del principio
    - Crear un ejemplo de c√≥digo "antes" y "despu√©s" que muestre claramente la diferencia
    - Preparar una explicaci√≥n para presentar al equipo sobre el principio implementado

## ‚úÖ M√≥dulo 8-B: Implementaci√≥n de Patrones de Dise√±o

### üìå Tareas por Patr√≥n de Dise√±o

- Cada miembro que elija un patr√≥n de dise√±o debe:
- Investigar el patr√≥n asignado, su estructura y casos de uso t√≠picos
- Identificar una situaci√≥n espec√≠fica en el microservicio donde el patr√≥n sea aplicable
- Implementar el patr√≥n de manera que resuelva un problema real del proyecto
- Demostrar c√≥mo el patr√≥n mejora la flexibilidad, mantenibilidad o extensibilidad del c√≥digo
- Preparar una explicaci√≥n para presentar al equipo sobre el patr√≥n implementado

## üß† Beneficios Esperados

- Al completar esta fase, el equipo habr√°:
- Aplicado principios SOLID de manera pr√°ctica y comprensible
- Implementado patrones de dise√±o que resuelvan problemas reales
- Mejorado la calidad del c√≥digo mediante refactoring sistem√°tico
- Desarrollado habilidades de investigaci√≥n y aplicaci√≥n de conceptos te√≥ricos
- Fortalecido las habilidades de comunicaci√≥n t√©cnica y trabajo en equipo
-

## üìå Consideraciones T√©cnicas

- Mantener compatibilidad con la arquitectura hexagonal existente
- Actualizar la documentaci√≥n de Swagger si es necesario
- Conservar la funcionalidad de los stored procedures
- Mantener la contenerizaci√≥n con Docker

## üß™ Fase 9: Testing del Microservicio

### üéØ Objetivo General

- Alcanzar al menos un 80% de cobertura de c√≥digo mediante pruebas automatizadas que validen el comportamiento del
  dominio, los casos de uso, los adaptadores y los endpoints del microservicio.

## ‚úÖ M√≥dulo 9-A: Tests Unitarios con Arquitectura Hexagonal

### üìå Objetivo:

- Probar en forma aislada cada unidad de l√≥gica del sistema, mockeando las dependencias externas mediante los puertos (
  interfaces).
- La clave es testear desde el interior hacia el exterior:

| Capa                    | Clase principal          | Qu√© probar                                     | C√≥mo testear                             |
|-------------------------|--------------------------|------------------------------------------------|------------------------------------------|
| application/service     | PatientService           | Casos de uso: crear, buscar, eliminar          | Mock PatientRepositoryPort               |
| adapter/in/rest         | PatientController        | Mapeo HTTP ‚Üî Dominio + manejo de errores       | Mock PatientUseCase                      |
| adapter/out/persistence | PatientRepositoryAdapter | Persistencia y mapeo entre entidades y dominio | Mock JpaRepository y PatientEntityMapper |

#### üìò Ejemplo 1: PatientServiceTest.java

```java

@ExtendWith(MockitoExtension.class)
class PatientServiceTest {

  @Mock
  private PatientRepositoryPort repository;

  @InjectMocks
  private PatientService service;

  @Test
  void shouldCreatePatientWhenDniIsNotTaken() {
    Patient patient = new Patient("123", "Ana", "Lopez", "OSDE", "ana@mail.com", "123456");

    when(repository.existsByDni("123")).thenReturn(false);
    when(repository.save(any())).thenReturn(patient);

    Patient result = service.createPatient(patient);

    assertEquals("Ana", result.getFirstName());
    verify(repository).save(patient);
  }

  @Test
  void shouldThrowDuplicatedExceptionIfDniExists() {
    Patient patient = new Patient("123", "Ana", "Lopez", "OSDE", "ana@mail.com", "123456");

    when(repository.existsByDni("123")).thenReturn(true);

    assertThrows(PatientDuplicatedException.class, () -> {
      service.createPatient(patient);
    });
  }

}
```

#### üìò Ejemplo 2: PatientControllerTest.java

```java

@WebMvcTest(PatientController.class)
class PatientControllerTest {

  @Autowired
  private MockMvc mockMvc;

  @MockBean
  private PatientUseCase useCase;

  @Test
  void shouldReturnPatientByDni() throws Exception {
    Patient patient = new Patient("123", "Ana", "Lopez", "OSDE", "ana@mail.com", "123456");

    when(useCase.findByDni("123")).thenReturn(patient);

    mockMvc.perform(get("/patients/dni/123"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.firstName").value("Ana"));
  }

}
```

#### üìò Ejemplo 3: PatientRepositoryAdapterTest.java

```java

@ExtendWith(MockitoExtension.class)
class PatientRepositoryAdapterTest {

  @Mock
  private PatientJpaRepository jpaRepository;

  @Mock
  private PatientEntityMapper entityMapper;

  @InjectMocks
  private PatientRepositoryAdapter adapter;

  @Test
  void shouldSavePatientSuccessfully() {
    Patient patient = new Patient("123", "Ana", "Lopez", "OSDE", "ana@mail.com", "123456");
    PatientEntity entity = new PatientEntity();

    when(entityMapper.toEntity(patient)).thenReturn(entity);
    when(jpaRepository.save(entity)).thenReturn(entity);
    when(entityMapper.toDomain(entity)).thenReturn(patient);

    Patient result = adapter.save(patient);

    assertEquals("123", result.getDni());
  }

}
```

## ‚úÖ M√≥dulo 9-B: Tests de Integraci√≥n

### üìå Objetivo:

- Probar que los componentes se integran correctamente en conjunto, especialmente desde el controlador hasta la
  persistencia.
- Recomendaciones:
- Usar @SpringBootTest o @WebMvcTest con MockMvc.
- Crear un perfil de test (application-test.yml) para evitar la conexi√≥n a MySQL real.
- Se puede mockear el acceso a base de datos o usar H2 en memoria para simular procedimientos almacenados si es
  necesario.

- üìå Si quieren pruebas realistas con base de datos, pueden usar Testcontainers, aunque no es obligatorio para este
  ejercicio.

### üìÅ Estructura sugerida de tests

```
src/test/java/com/swissmedical/pacients/
        ‚îú‚îÄ‚îÄapplication/
        ‚îÇ ‚îî‚îÄ‚îÄservice/
        ‚îÇ   ‚îî‚îÄ‚îÄPatientServiceTest.java
        ‚îú‚îÄ‚îÄinfrastructure/
            ‚îÇ ‚îî‚îÄ‚îÄadapter/
            ‚îÇ ‚îú‚îÄ‚îÄin/rest/controller/
            ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄPatientControllerTest.java
            ‚îÇ ‚îî‚îÄ‚îÄout/persistence/mysql/repository/
            ‚îÇ ‚îî‚îÄ‚îÄPatientRepositoryAdapterTest.java
        ‚îî‚îÄ‚îÄshared/
        ‚îî‚îÄ‚îÄexceptions/
        ‚îî‚îÄ‚îÄGlobalExceptionHandlerTest.java (opcional)
```

## üìå Herramientas y configuraci√≥n

- Usar JUnit 5, Mockito, MockMvc.
- Medir cobertura con Jacoco (jacoco-maven-plugin o equivalente).
- Verificar que la cobertura supere el 80% en las capas de dominio, aplicaci√≥n y adaptadores.

## üß† Beneficios esperados

- Validaci√≥n clara del comportamiento esperado y no esperado.
- Posibilidad de refactorizar sin miedo.
- Cobertura s√≥lida en l√≥gica de negocio.
- Separaci√≥n de responsabilidades probadas.

## üß© Fase 10: Logging y Observabilidad

### üéØ Objetivo

- Agregar logs al microservicio para poder entender su comportamiento, detectar errores y seguir el flujo de ejecuci√≥n
  sin depurar con el IDE.

### üîß Tecnolog√≠a sugerida

- Usar el sistema de logs por defecto de Spring Boot: SLF4J + Logback.

Para loggear, usar:

- `Logger logger = LoggerFactory.getLogger(...)`
- o `@Slf4j` de Lombok.

- üß™ Actividad
- Agreg√° logs en partes clave de tu app (controller, service, repository, excepciones).
- Us√° diferentes niveles de log:
    - info: eventos normales (ej: "Paciente creado").
    - warn: situaciones sospechosas.
    - error: cuando ocurre una excepci√≥n.
- Ejecut√° la app y observ√° los logs en consola.

_Reflexion√°_:

- ¬øQu√© nivel de log usaste m√°s?
- ¬øTe ayudaron los logs a entender el flujo?
- ¬øQu√© mejorar√≠as?
- ¬øQu√© datos ser√≠a mejor no loggear?

### ‚úÖ Requisitos m√≠nimos

- Al menos 2 niveles de log implementados.
- Logs visibles en consola.
- Poder explicar por qu√© se loggea en cada parte.

- üß† Sugerencia: explor√° c√≥mo cambiar el nivel de logging desde application.yml.

---

# üìù Check List

- [ x ] Implementar operaciones CRUD a pacientes
- [ x ] Manejo de excepciones personalizadas
- [ x ] Dividir el proyecto en capas (Modelo, Controlador, Servicio, Repositorio)
- [ x ] Uso de DTOs y Mappers
- [ x ] Crear requests de prueba
- [ x ] Documentar el API con Swagger
- [ x ] Crear el archivo Dockerfile para el `build` de la aplicaci√≥n
- [ x ] Crear el archivo docker-compose.yml para contenerizar la aplicaci√≥n y la base de datos MySQL

## Estructura del Proyecto

```
patients/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ com/swissmedical
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ patients/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controller/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exception/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mappers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PatientsApplication.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.properties
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ static
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ templates
‚îÇ   ‚îî‚îÄ‚îÄ test/
‚îÇ       ‚îî‚îÄ‚îÄ java/
‚îÇ           ‚îî‚îÄ‚îÄ com/swissmedical/patients/
‚îÇ               ‚îî‚îÄ‚îÄ PatientsApplicationTests.java
‚îî‚îÄ‚îÄ pom.xml
docker-compose.yml
Dockerfile
README.md
```

---

# Comentarios del archivo docker-compose.yml

- Para que dos contenedores est√©n comunicados, es necsario que est√©n en la misma red
- Es necesario definir la variable de entorno de `host` para que la aplicaci√≥n de Spring identifique correctamente la
  base de datos MySQL
- La secci√≥n de `healthcheck` sirve para verificar que el servicio de MySQL est√© listo antes de que la aplicaci√≥n Spring
  Boot intente conectarse a √©l
- Esto es importante para evitar errores de conexi√≥n al iniciar la aplicaci√≥n
- Al `depends_on` se le agrega el `condition: service_healthy` para que la aplicaci√≥n espere a que el servicio de MySQL
  est√© completamente operativo antes de iniciar
- A lo √∫ltimo se define las redes que se va a utilizar en el contenedor

## Detalles sobre el apartado `healthcheck`

- `test`: Comando que se ejecuta para verificar la salud del contenedor. En este caso, se usa `mysqladmin ping` para
  comprobar si el servidor MySQL est√° respondiendo.
- `timeout`: Tiempo m√°ximo que se espera para que el comando se ejecute. Si el comando no responde en este tiempo, se
  considera que la verificaci√≥n ha fallado.
- `retries`: N√∫mero de intentos que se realizan antes de considerar que el contenedor no est√° saludable.
- `interval`: Tiempo entre cada intento de verificaci√≥n de salud.
- `start_period`: Tiempo que se espera antes de comenzar a realizar verificaciones de salud. Esto es √∫til para dar
  tiempo al contenedor para iniciar completamente antes de que se realicen las primeras verificaciones.

## Driver `bridges`

- El driver `bridge` es el controlador de red predeterminado en Docker
- Permite que los contenedores se comuniquen entre s√≠ y con el host, creando una red aislada para los contenedores que
  se ejecutan en el mismo host

```yaml
services:
  # Imagen de la Base de Datos
  mysql:
    image: mysql:8.0-debian
    container_name: spring_db
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
    ports:
      - "${MYSQL_PORT}:3306"
    volumes:
      - ./db_data:/var/lib/mysql
    networks:
      - app-net
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p$$MYSQL_ROOT_PASSWORD" ]
      timeout: 20s
      retries: 10
      interval: 10s
      start_period: 60s  # Aumentado para dar m√°s tiempo

  app:
    build: .
    container_name: spring_app
    environment:
      MYSQL_HOST: mysql
      MYSQL_PORT: ${MYSQL_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_ROOT_USER: ${MYSQL_ROOT_USER}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_PARAMS: ${MYSQL_PARAMS}
    ports:
      - "8000:8000"
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - app-net

networks:
  app-net:
    driver: bridge
```

---

# Implementaci√≥n de Store Procedures

- Se cre√≥ los archivos `init.sql` y `stored_procedures.sql` para definir los procedimientos almacenados y poblar la base
  de datos con datos de ejemplo.
- Se aplic√≥ la nomeclatura con un n√∫mero al inicio de cada archivo para asegurar que se ejecuten en el orden correcto al
  iniciar el contenedor de MySQL.
- Se configur√≥ el archivo `docker-compose.yml` para montar estos archivos en el directorio
  `/docker-entrypoint-initdb.d/` del contenedor MySQL, lo que permite que se ejecuten autom√°ticamente al iniciar el
  contenedor.
- Dentro del repositorio se utiliz√≥ la anotaci√≥n `@Query` con `nativeQuery = true` para invocar los procedimientos
  almacenados desde Java.

```java

@Query(value = "CALL buscar_paciente_por_dni(:dni)", nativeQuery = true)
Optional<Paciente> buscarPorDniConSP(@Param("dni") String dni);
```

- No olvidar realizar el `build` de la aplicaci√≥n y el `docker-compose up` para que se creen los contenedores y se
  ejecuten los scripts de inicializaci√≥n.

---

# Refactorizaci√≥n a Arquitectura Hexagonal

- Se reorganiz√≥ el proyecto para adoptar una arquitectura hexagonal, separando claramente las capas de dominio y de
  infrastructura.
- Se definieron los puertos de entrada y salida para el dominio, permitiendo que la l√≥gica de negocio no dependa de
  detalles t√©cnicos como JPA o REST.
- Se implementaron adaptadores para conectar el dominio con la infraestructura, manteniendo el n√∫cleo del negocio
  independiente de las tecnolog√≠as externas.

## Nueva Estructura del Proyecto

```bash
src/
‚îî‚îÄ‚îÄ main/
    ‚îî‚îÄ‚îÄ java/
        ‚îî‚îÄ‚îÄ com.swissmedical/
            ‚îî‚îÄ‚îÄ pacients/
                ‚îú‚îÄ‚îÄ application/
                ‚îÇ   ‚îú‚îÄ‚îÄ domain/
                ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/
                ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Patient.java
                ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ port/
                ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ in/
                |   |           ‚îî‚îÄ‚îÄ PatienteUseCase.java
                ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ out/
                ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ PatienteRepositoryPort.java
                ‚îÇ   ‚îî‚îÄ‚îÄ service/
                ‚îÇ       ‚îî‚îÄ‚îÄ PatienteService.java
                ‚îú‚îÄ‚îÄ infrastructure/
                ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
                ‚îÇ   |    ‚îú‚îÄ‚îÄ in/rest/
                ‚îÇ   |    ‚îÇ   ‚îú‚îÄ‚îÄ controller/
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientApi.java
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientController.java
                ‚îÇ   |    ‚îÇ   |   ‚îî‚îÄ‚îÄ RootController.java 
                ‚îÇ   |    ‚îÇ   ‚îî‚îÄ‚îÄ dto/
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientCreateDto.java
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientUpdateDto.java
                ‚îÇ   |    ‚îÇ   |   ‚îî‚îÄ‚îÄ PatientResponseDto.java
                ‚îÇ   |    ‚îÇ   ‚îî‚îÄ‚îÄ mapper/ 
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientCreateMapper.java
                ‚îÇ   |    ‚îÇ   |   ‚îú‚îÄ‚îÄ PatientUpdateMapper.java
                ‚îÇ   |    ‚îÇ   |   ‚îî‚îÄ‚îÄ PatientResponseMapper.java
                ‚îÇ   |    ‚îî‚îÄ‚îÄ out/persistence/mysql/
                ‚îÇ   |        ‚îú‚îÄ‚îÄ entity/
                ‚îÇ   |        ‚îÇ   ‚îî‚îÄ‚îÄ PatientEntity.java
                ‚îÇ   |        ‚îú‚îÄ‚îÄ mapper/
                ‚îÇ   |        ‚îÇ   ‚îî‚îÄ‚îÄ PatientEntityMapper.java
                ‚îÇ   |        ‚îî‚îÄ‚îÄ repository/
                ‚îÇ   |            ‚îú‚îÄ‚îÄ PatientJpaRepository.java
                ‚îÇ   |            ‚îî‚îÄ‚îÄ PatientRepositoryAdapter.java
                ‚îÇ   ‚îî‚îÄ‚îÄ config/
                ‚îÇ       ‚îî‚îÄ‚îÄ OpenApiConfig.java
                ‚îî‚îÄ‚îÄ shared/
                    ‚îî‚îÄ‚îÄ exceptions/
                    |   ‚îú‚îÄ‚îÄ GlobalExceptionHandler.java
                    |   ‚îú‚îÄ‚îÄ PatientNotFoundException.java
                    |   ‚îî‚îÄ‚îÄ PatientDuplicatedException.java
                    ‚îî‚îÄ‚îÄ utils/
                        ‚îú‚îÄ‚îÄ ErrorMessages.java
                        ‚îî‚îÄ‚îÄ ResponseCode.java
                    
```

---

# Implementaci√≥n de SOLID y Patrones de Dise√±o

## Segregaci√≥n de interfaces (Intefaces segregation)

- Este principio establece que se deben separar en interfaces diferentes m√©todos con funciones espec√≠ficas
- En esta ocasi√≥n, separ√© en interfaces cada caso de uso (Use Case) dependeniendo su m√©todo
    - `CreatePatientUseCase`: Se encapsulan los m√©todos relacionados con crear datos
    - `ReadPatientUseCase`: Se encapsulan los m√©todos relacionados con obtener datos
    - `UpdatePatientUseCase`: Se encapsulan los m√©todos relacionados con actualizar datos
    - `DeletePatientUseCase`: Se encapsulan los m√©todos relacionados con eliminar datos

## Patr√≥n Proxy

- Para mi elecci√≥n de Patr√≥n de Dise√±o, implement√© el patr√≥n Proxy para la clase `PatientController`
- En este caso, se utiliz√≥ Programaci√≥n Orientada a Aspectos (AOP) para crear un proxy que envuelve al controlador
- Anotaciones utilizadas:
    - `@Aspect`: Define la clase como un aspecto de AOP
    - `@Around`: Define un m√©todo que se ejecuta alrededor de la ejecuci√≥n de un m√©todo
    - `within`: Especifica que el aspecto se aplica a m√©todos con la anotaci√≥n `@RestController`
- Se implement√≥ un `logger` para ejecutarse cada vez que se realiza una petici√≥n al controlador, registrando el nombre
  del m√©todo y los par√°metros recibidos

```java

@Aspect
@Component
public class LoggingAspect {

  private final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

  @Around("within(@org.springframework.web.bind.annotation.RestController *)")
  public Object logAroundController(ProceedingJoinPoint joinPoint) throws Throwable {
    String clase = joinPoint.getSignature().getDeclaringTypeName();
    String metodo = joinPoint.getSignature().getName();
    Object[] args = joinPoint.getArgs();

    if (!clase.contains("PatientController")) {
      return joinPoint.proceed();
    }

    if (args.length == 0) {
      logger.info("[PROXY] Endpoint llamado: /{} sin argumentos", metodo);
      return joinPoint.proceed();
    }

    logger.info("[PROXY] Endpoint llamado: /{} con argumentos: {}", metodo, Arrays.toString(args));

    return joinPoint.proceed();
  }
}
```

_Observaciones_

- Se crea una clase con anotacion `@Component` para que Spring la reconozca como un componente dentro del Spring
  Container
- Dentro de la anotaci√≥n `@Around` se define con `within` que se aplique a todos los m√©todos de las clases
  que tengan la anotaci√≥n `@RestController`
- La funci√≥n `logAroundController` recibe un `ProceedingJoinPoint` que permite acceder a la informaci√≥n del m√©todo
  invocado (como de qu√© clase proviene, nombre del m√©todo y par√°metros)

## Patr√≥n Builder

- El Patr√≥n Builder consiste en que una clase puede definir sus propiedades de forma din√°mica mediante un constructor
- En este caso, se implement√≥ el patr√≥n Builder para la clase `Patient` dentro de la capa de `model`

```java
public class Patient {
  private Long id;
  private String firstName;
  private String lastName;
  private String email;
  private String phoneNumber;
  private String dni;
  private String memberNumber;
  private LocalDate birthDate;
  private boolean isActive;
  private String socialSecurity;

  private Patient(PatientBuilder builder) {
    this.id = builder.id;
    this.firstName = builder.firstName;
    this.lastName = builder.lastName;
    this.email = builder.email;
    this.phoneNumber = builder.phoneNumber;
    this.dni = builder.dni;
    this.memberNumber = builder.memberNumber;
    this.birthDate = builder.birthDate;
    this.isActive = builder.isActive;
    this.socialSecurity = builder.socialSecurity;
  }

  public static PatientBuilder builder() {
    return new PatientBuilder();
  }

  public static class PatientBuilder {
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    private String phoneNumber;
    private String dni;
    private String memberNumber;
    private LocalDate birthDate;
    private boolean isActive;
    private String socialSecurity;

    private PatientBuilder() {
    }

    public PatientBuilder id(Long id) {
      this.id = id;
      return this;
    }

    public PatientBuilder firstName(String firstName) {
      this.firstName = firstName;
      return this;
    }

    public PatientBuilder lastName(String lastName) {
      this.lastName = lastName;
      return this;
    }

    public PatientBuilder email(String email) {
      this.email = email;
      return this;
    }

    public PatientBuilder phoneNumber(String phoneNumber) {
      this.phoneNumber = phoneNumber;
      return this;
    }

    public PatientBuilder dni(String dni) {
      this.dni = dni;
      return this;
    }

    public PatientBuilder memberNumber(String memberNumber) {
      this.memberNumber = memberNumber;
      return this;
    }

    public PatientBuilder birthDate(LocalDate birthDate) {
      this.birthDate = birthDate;
      return this;
    }

    public PatientBuilder isActive(boolean isActive) {
      this.isActive = isActive;
      return this;
    }

    public PatientBuilder socialSecurity(String socialSecurity) {
      this.socialSecurity = socialSecurity;
      return this;
    }

    public Patient build() {
      return new Patient(this);
    }
  }
}
```
